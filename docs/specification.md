# AI 自主开发规范 (ADDS) v2.0 核心指南

> 本指南定义了一套结构化方法，旨在帮助 AI Agent 在长周期的软件开发任务中，能够跨越多个上下文窗口（Context Window）持续、稳定、安全地推进项目。

---

## 1. 核心挑战：上下文断裂

长周期 AI 任务（Long-running Agent Tasks）面临的最大问题是**上下文断裂**：
- **状态丢失**：每个新会话（Session）开始时，Agent 都是"失忆"的。
- **过度冒进**：Agent 倾向于一次性完成（One-shot）所有功能，导致代码质量下降或上下文超出。
- **过早完工**：Agent 看到已有代码，容易误判任务已完成。
- **环境碎片**：未配置的环境或丢失的依赖导致新会话无法立即开始工作。
- **回归盲区**：新功能破坏旧功能, Agent 毫无察觉地继续前进。
- **安全失控**：Agent 执行危险命令而没有任何约束。

---

## 2. 双 Agent 角色模型

我们将任务分解为两个核心阶段，由两个不同的提示词（或 Agent）执行：

### 2.1 初始化 Agent (Initializer Agent)
- **职责**：项目启动。
- **触发条件**：项目首次启动，或不存在 `.ai/feature_list.json` 文件。
- **任务**：
    - 阅读原始需求（`app_spec.md` 或 `app_spec.txt`）。
    - 拆解功能清单，生成 `.ai/feature_list.json`（包含 50-200 个原子测试用例）。
    - 搭建基础目录结构。
    - 生成 `.ai/architecture.md` 记录技术选型和架构决策。
    - 编写 `init.sh` 自动化环境配置。
    - 提交初始 Git Commit。

### 2.2 编码 Agent (Coding Agent)
- **职责**：增量迭代。
- **触发条件**：后续所有会话。
- **任务**：
    - 读取进度文件（`progress.log`）和功能清单。
    - **执行环境验证**（运行 `init.sh` 或冒烟测试）。
    - **运行 1-2 个核心功能的回归测试**。
    - 运行测试确定当前状态。
    - **每次只选择一个**功能进行开发。
    - 完成开发、自测、Git 提交并更新进度。

---

## 3. 标准项目骨架 (`.ai/` 目录)

每个项目必须包含以下"自描述"文件：

- **`.ai/feature_list.json`**：功能的单一事实来源 (Single Source of Truth)。
  每个功能必须包含 `id`, `category`, `description`, `steps`, `passes`, `priority`, `core`, `test_cases`, `security_checks` 字段。
- **`progress.log`**：面向人类/Agent 的自然语言进度总结。
  采用增量追加模式，记录"已完成"、"进行中"、"待办事项"及下一步交接说明。
- **`CORE_GUIDELINES.md`**：(新) 极简自引导说明书。放置在项目根目录，供 AI 瞬间启动并对齐开发流程。
- **`.ai/architecture.md`**：记录项目架构、技术栈选择和核心数据流。
- **`.ai/session_log.jsonl`**：机器可读的会话历史记录（每行一个 JSON 对象）。
- **`init.sh`**：脚本化环境。运行此脚本后，任何 Agent 应该能立即执行测试或启动开发。

---

## 4. 增量开发流程 (SDLC for AI)

每个开发会话必须遵循以下严格步骤：

### 4.1 环境对齐 (Align)
- 执行 `pwd`, `ls` 熟悉结构。
- 读取 `CORE_GUIDELINES.md` (极速启动)。
- 读取 `progress.log` 和 `.ai/feature_list.json`。
- 查看 `git log --oneline -10` 了解最近的变更。

### 4.2 环境验证 (Bootstrap)
- 执行 `init.sh` 或现有测试，确保 Agent 接手的是一个正常的项目。
- 检查依赖是否安装（`node_modules/`, `venv/`, etc.）。
- 检查服务是否运行（`curl localhost:3000/health` etc.）。
- 如果发现问题，**先修复再继续**。

### 4.3 回归验证 (Regression Check) ⭐ 新增
- 从已完成的功能中挑选 1-2 个核心功能，运行其测试。
- 如果已有功能被破坏：
  1. 🛑 **立即停止**新功能开发。
  2. 🔧 **优先修复**回归问题。
  3. 在 `feature_list.json` 中将受影响功能标记为 `"status": "regression"`。
  4. 📝 **记录**到 `progress.log`。

### 4.4 选择任务 (Select)
- 从 `feature_list.json` 中挑选最高优先级的 `passes: false` 任务。
- 确保其所有 `dependencies` 均已完成。
- 将状态更新为 `"status": "in_progress"`。

### 4.5 执行实现 (Execute)
- 编写代码。**严禁**超出当前选定的任务范围。
- 遵循项目编码规范，添加必要注释。
- 编写相应的测试用例。

### 4.6 质量保证 (QA)
- 使用工具（如模拟器、浏览器、单元测试）验证功能。
- **拒绝"自认为完成"**：Agent 必须提供工具执行结果（断言、日志、截图）作为完成证据。
- 根据项目类型选择验证方式（详见第 5 节）。

### 4.7 持久化 (Persist)
- 执行 `git add` / `git commit`，备注信息需详尽。
- 更新 `feature_list.json` 中的 `passes` 状态。
- 在 `progress.log` 中留下"下一位开发者"的交接说明。

---

## 5. 测试与验证标准

### 5.1 通用规则
- **原子性测试**：每个功能点必须能够独立测试。
- **证据驱动**：所有功能必须提供工具执行结果（日志、断言输出、截图）作为完成证据。
- **测试用例内嵌**：每个功能在 `feature_list.json` 中必须包含 `test_cases` 字段。

### 5.2 Web 项目 (E2E 优先)
- 必须使用 Playwright/Cypress 等工具进行端到端模拟。
- 模拟真实用户操作（点击、输入、滚动）。
- 验证页面跳转、错误消息显示、UI 渲染。
- **禁止**使用 API 调用绕过 UI 验证。

### 5.3 API 项目
- 验证响应状态码、数据格式、错误处理。
- 验证数据库状态正确。
- 使用 pytest / Newman 等工具执行自动化测试。

### 5.4 CLI 项目
- 测试命令行输入/输出。
- 验证退出码正确。
- 测试异常参数处理。

---

## 6. 安全执行规范 ⭐ 新增

### 6.1 命令白名单

AI 在执行任何命令前**必须**验证安全性。

#### ✅ 允许的命令

| 类别 | 命令 |
| :--- | :--- |
| **文件操作** | `ls`, `cat`, `head`, `tail`, `wc`, `grep`, `find`, `cp`, `mv` |
| **Node.js** | `npm`, `node`, `npx`, `yarn` |
| **Python** | `pip`, `python`, `pytest`, `black`, `flake8`, `mypy` |
| **Go** | `go`, `gofmt` |
| **Rust** | `cargo`, `rustc`, `rustfmt` |
| **版本控制** | `git` (all subcommands) |
| **进程管理** | `ps`, `lsof`, `sleep` |

#### ❌ 禁止的命令

| 类别 | 命令 | 原因 |
| :--- | :--- | :--- |
| **提权** | `sudo`, `su` | 系统级风险 |
| **权限** | `chmod`, `chown` (除非明确必要) | 权限变更 |
| **破坏性** | `rm -rf /`, `mkfs`, `fdisk` | 数据不可恢复 |
| **网络后门** | `nc`, `netcat`, `telnet` | 安全隐患 |
| **防火墙** | `iptables`, `route` | 网络配置变更 |
| **盲目下载** | `curl \| bash`, `wget \| sh` | 不受审查的脚本 |
| **系统杀进程** | `kill -9` (系统进程) | 系统稳定性 |

### 6.2 执行前检查清单

每个命令执行前必须验证：

1. ✅ 命令在白名单中？
2. ✅ 参数安全？
3. ✅ 不影响系统文件？
4. ✅ 不可逆操作已备份？
5. ✅ 如有疑问，先询问用户。

---

## 7. 功能管理与锁定 ⭐ 新增

### 7.1 核心功能 (core: true)
- ❌ **不可删除**
- ⚠️ 修改需要明确理由，并记录变更原因
- ✅ 可以调整优先级

### 7.2 扩展功能 (core: false)
- ✅ 可以删除（须记录原因）
- ✅ 可以修改描述/步骤
- ✅ 可以推迟

### 7.3 需求变更流程
1. 更新 `app_spec.md` 反映新需求。
2. 评估对现有功能的影响。
3. 更新 `feature_list.json`（添加/修改/推迟）。
4. 在 `progress.log` 记录变更理由。

---

## 8. 特殊情况处理

### 8.1 回归问题 (Regression)
```json
{
  "id": "F005",
  "status": "regression",
  "regression_details": {
    "detected_at": "2026-02-26T14:00:00Z",
    "symptoms": "登录功能返回 500 错误",
    "likely_cause": "F010 的数据库迁移破坏了用户表",
    "affected_tests": ["test-005-01"]
  }
}
```
- 优先修复回归问题，再继续新功能。

### 8.2 阻塞问题 (Blocked)
- 更新功能状态为 `"status": "blocked"`，记录 `blocked_reason`。
- 跳过该功能，选择下一个可执行功能。
- 在 `progress.log` 记录阻塞详情。

### 8.3 项目中断恢复
1. 读取 `progress.log` 了解历史。
2. 读取 `.ai/feature_list.json` 查看当前状态。
3. 执行 `git log` 查看最近提交。
4. 运行环境验证和回归测试。
5. 继续下一个待处理功能。

---

## 9. Git 提交规范

- 每次功能完成**必须**提交。
- **严禁**一次提交多个功能。
- 提交信息格式：

```
<type>(<scope>): <description> [Closes #feature-id]

- 实现内容 1
- 实现内容 2
- 添加测试用例
```

**Type 类型**：
- `feat:` 新功能
- `fix:` Bug 修复
- `refactor:` 代码重构
- `test:` 测试相关
- `docs:` 文档更新
- `chore:` 构建/工具相关

---

## 10. 项目完成标准

| 维度 | 要求 |
| :--- | :--- |
| **功能完成** | 所有功能 `passes: true`，无 `blocked` 或 `regression` |
| **测试覆盖** | 测试覆盖率 ≥ 70% |
| **代码质量** | 无 lint 错误, 通过类型检查 |
| **文档** | README 完整, API 文档清晰, 代码注释充分 |
| **Git 历史** | 每个功能一个提交, 消息清晰, 无冗余 |

---

## 11. 最佳实践

### 功能拆分
- **粒度适中**：一个功能 1-4 小时完成
- **独立可测**：不依赖未完成的功能
- **价值明确**：每个功能有清晰的业务价值
- **边界清晰**：功能之间职责分明

### 代码质量
- **测试驱动**：先写测试，再写实现
- **持续重构**：保持代码整洁
- **文档同步**：代码和文档保持一致
- **版本控制**：小步提交，频繁提交

### 状态管理
- **及时更新**：完成功能后立即更新状态。
- **人性化日志**：在 `progress.log` 增量记录每个会话的决策与成果。
- **定期回顾**：检查进度和剩余工作

---

## 📚 开始使用

1. **检查项目状态** — 查看是否已存在 `.ai/feature_list.json`
2. **确定当前模式** — 初始化代理 or 编码代理
3. **按照流程执行** — 严格遵循上述规范

**记住**：你的目标是高质量、可持续、安全地完成项目开发。遵循规范，减少犯错，确保每个功能都经过充分验证。

**开始吧!** 🚀
